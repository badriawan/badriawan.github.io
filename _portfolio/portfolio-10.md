---
title: "SLAM Based Mobile Robot Navigation for Airport Robotics Model Prototyping "
excerpt: Research Project <br/><img src='/images/turtlebot.gif'>"
collection: portfolio
---

## Build a SLAM and Obstacle Avoidance System Using ROS Navigation Stack

<p align="center">
<img src="/images/turtlebot.gif?raw=true" center=true width="55%"/>
</p>


## Brief Overview

This project consist of 3 members and i have responsibilites to analyze the path planning using A*.

- **First Part:** Implement Simultaneous Localization and Mapping (SLAM) using the ROS1 Navigation Stack to enable the TurtleBot3 robot to build a map of its environment while localizing itself within it.

- **Second Part:** Integrate obstacle avoidance capabilities to ensure the robot can navigate safely through the environment by detecting and avoiding obstacles using sensor data.

## Project Structure

- **config**
  - `costmap_common_params.yaml`
  - `local_costmap_params.yaml`
  - `global_costmap_params.yaml`
  - `base_local_planner_params.yaml`
- **launch**
  - `navigation.launch`
  - `slam_gmapping.launch`
- **scripts**
  - `obstacle_avoidance.py`
- **src**
  - (Source files and nodes)
- **urdf**
  - `turtlebot3_model.urdf`

## Solutions

### How I Built the System

1. **Set Up the Workspace and ROS1 Packages:**
   - Created a ROS1 workspace and initialized necessary packages.
   - Organized the workspace with folders: `launch`, `config`, `scripts`, `src`, and `urdf`.

2. **Installed Necessary Dependencies:**
   - Installed essential ROS1 packages like `turtlebot3`, `navigation`, `slam_gmapping`, and sensor drivers.
   - Added custom libraries and dependencies as needed.

3. **Configured SLAM Parameters:**
   - Edited the `gmapping` parameters in `slam_gmapping.launch` to optimize mapping performance.
   - Adjusted parameters such as map update rates, minimum score, and sensor configurations.

4. **Set Up the Robot Model:**
   - Defined the robot's physical parameters in a Unified Robot Description Format (`.urdf`) file.
   - Included sensors like laser scanners and configured their positions and orientations.

5. **Created Launch Files:**
   - **`slam_gmapping.launch`:** Launches the SLAM node along with the robot state publisher and necessary transforms.
   - **`navigation.launch`:** Starts the navigation stack, including move base, costmaps, and planners.

6. **Implemented Obstacle Avoidance Script:**
   - Developed `obstacle_avoidance.py` to subscribe to laser scan data and publish velocity commands.
   - Utilized algorithms like Vector Field Histogram (VFH) for real-time obstacle avoidance.

7. **Adjusted Costmaps and Planners:**
   - Configured local and global costmaps in YAML files to handle obstacle information effectively.
   - Tuned parameters like inflation radius, obstacle range, and resolution.
   - Customized the local planner (`DWAPlanner`) parameters for smoother navigation.

8. **Integrated All Components:**
   - Ensured all nodes and configurations are correctly referenced in the launch files.
   - Verified frame transformations (`/odom`, `/base_link`, `/map`) using `tf` tools.
   - Tested the integration in simulation before deploying to the physical robot.

9. **Tested in Simulation and on Real Robot:**
   - Used Gazebo for simulation testing to refine parameters without risking hardware.
   - Deployed the system on the actual TurtleBot3 robot and conducted real-world tests.
   - Monitored performance using RViz for visualization of mapping and navigation.

### How I Performed the System Analysis

1. **Testing in Various Environments:**
   - Evaluated the system in different simulated and real environments with varying complexity.
   - Assessed how well the robot could map and navigate in cluttered spaces versus open areas.

2. **Adjusting Sensor Noise Parameters:**
   - Modified sensor noise levels to simulate different real-world conditions.
   - Observed the impact on SLAM accuracy and adjusted parameters in the `gmapping` configuration.

3. **Analyzing Path Planning and Execution:**
   - Examined the paths generated by the global and local planners. I choose A* instead of Djikstra for the global planner.
   - Identified issues such as oscillations or suboptimal paths and refined planner settings.

4. **Evaluating Obstacle Avoidance Performance:**
   - Tested the robot's response to dynamic obstacles introduced during navigation.
   - Tweaked obstacle avoidance algorithms to improve responsiveness and safety.

5. **Optimizing Resource Usage:**
   - Monitored CPU and memory usage to ensure the system runs efficiently on limited hardware.
   - Made code optimizations and adjusted update frequencies where necessary.

## Project Summary

Implementing SLAM and obstacle avoidance on a TurtleBot3 using the ROS1 Navigation Stack involves a careful integration of mapping, localization, path planning, and control. SLAM allows the robot to build a map of an unknown environment while simultaneously keeping track of its location within that map. Obstacle avoidance ensures safe navigation by allowing the robot to detect and maneuver around obstacles in real-time.

**A\* and Dijkstra Path Planners**

Both A\* (A-star) and Dijkstra's algorithms are fundamental graph search algorithms used for finding the shortest path between nodes in a graph. In this project, I used the A*.

### A\* Algorithm

**Overview:**

- **Purpose:** Finds the shortest path from a start node to a goal node using heuristics to guide the search more efficiently.
- **Characteristics:**
  - Combines features of Dijkstra's algorithm and Best-First Search.
  - Utilizes a heuristic function to estimate the cost from the current node to the goal.
  - More efficient than Dijkstra's algorithm in many cases due to focused exploration.

**How It Works:**

1. **Initialization:**
   - Start with the initial node and add it to an open list (nodes to be evaluated).
   - Initialize a closed list to keep track of nodes already evaluated.

2. **Evaluation Function:**
   - **\( f(n) = g(n) + h(n) \)**
     - \( g(n) \): Exact cost from the start node to the current node \( n \).
     - \( h(n) \): Heuristic estimate of the cost from \( n \) to the goal.
     - \( f(n) \): Total estimated cost of the cheapest solution through \( n \).

3. **Iteration:**
   - Select the node with the lowest \( f(n) \) from the open list.
   - Move it to the closed list.
   - For each neighbor of this node:
     - If the neighbor is in the closed list, skip it.
     - Calculate \( g(n) \), \( h(n) \), and \( f(n) \) for the neighbor.
     - If the neighbor is not in the open list or has a lower \( f(n) \), add it to the open list.

4. **Termination:**
   - Repeat the iteration until the goal node is selected from the open list.
   - Reconstruct the path from the goal node back to the start node.

**Heuristic Function \( h(n) \):**

- Must be **admissible**, meaning it never overestimates the actual minimal cost to reach the goal.
- Common heuristics:
  - **Euclidean Distance:** For movements in any direction.
  - **Manhattan Distance:** For grid movements in orthogonal directions.

**Advantages:**

- **Efficiency:** Reduces the number of nodes explored by focusing on promising paths.
- **Optimality:** Guarantees the shortest path if the heuristic is admissible and consistent.

**Disadvantages:**

- **Heuristic Dependency:** Performance relies heavily on the quality of the heuristic function.
- **Memory Usage:** Can consume significant memory for storing open and closed lists in large graphs.

**Usage in Robotics:**

- Ideal for real-time path planning where efficiency is crucial.
- Commonly used in grid-based maps for robots navigating in environments with obstacles.
- Applicable in both static and dynamic environments with appropriate modifications.

Key components and considerations:

- **SLAM with Gmapping:**
  - Utilizes laser scan data to incrementally build a map.
  - Requires tuning of parameters like linear and angular update thresholds, particles, and sensor data rate.

- **Navigation Stack:**
  - Comprises global and local planners, costmaps, and recovery behaviors.
  - Global planner computes an initial path, while the local planner adjusts it in real-time based on sensor data.

- **Costmaps:**
  - Represent the environment with obstacles inflated to account for the robot's size.
  - Critical parameters include obstacle range, raytrace range, and inflation radius.

- **Obstacle Avoidance:**
  - Relies on local planner and additional scripts (e.g., `obstacle_avoidance.py`) for reactive behaviors.
  - Must balance responsiveness with smooth navigation to avoid jerky movements.

Proper tuning and testing are essential to achieve reliable performance. Adjustments to the costmap resolutions, planner frequencies, and sensor configurations can significantly impact the robot's ability to navigate effectively.

## Using the Package

Follow these steps to set up and run the project:

1. **Create the Workspace:**

   ```bash
   cd ~
   mkdir -p catkin_ws/src
   cd catkin_ws/src
   ```

2. **Clone the Repository:**

   ```bash
   git clone https://github.com/yourusername/your_repository.git
   ```

3. **Install Dependencies:**

   ```bash
   cd ~/catkin_ws
   rosdep install --from-paths src --ignore-src -r -y
   ```

4. **Build the Workspace:**

   ```bash
   catkin_make
   source devel/setup.bash
   ```

5. **Run the SLAM Demo:**

   ```bash
   roslaunch your_package slam_gmapping.launch
   ```

6. **Run the Navigation Demo:**

   ```bash
   roslaunch your_package navigation.launch
   ```

7. **Launch RViz for Visualization:**

   ```bash
   rosrun rviz rviz -d src/your_package/rviz/navigation.rviz
   ```

8. **Control the Robot:**

   - **Keyboard Teleoperation:**

     ```bash
     roslaunch turtlebot3_teleop turtlebot3_teleop_key.launch
     ```

   - **Run Obstacle Avoidance Script:**

     ```bash
     rosrun your_package obstacle_avoidance.py
     ```

9. **Deploy on Physical Robot:**
   - Ensure the robot and workstation are on the same network.
   - Modify ROS master and host IP addresses accordingly.
   - Run the same launch files on the robot's onboard computer.

## Conclusion

This project showcases the implementation of SLAM and obstacle avoidance using the ROS1 Navigation Stack on a TurtleBot3 robot. By integrating mapping, localization, planning, and control, the robot is capable of autonomously exploring and navigating complex environments.

My Responsibilites Conclusion:

- A* Algorithm:
    1. Preferred for efficient pathfinding from a start to a goal node.
    2. Incorporates heuristics to reduce the search space and computation time.
    3. Optimal when the heuristic is admissible.
